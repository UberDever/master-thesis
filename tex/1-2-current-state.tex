\chapter{Анализ состояния работ в области анализа межъязыковых исходных текстов программ} \label{sec:num2}

\section{Теоретические и практические труды в отношении межъязыкового анализа} \label{ssec:num2}

На данный момент область межъязыкового анализа (в т.ч. не только статического) является
<<terra incognita>> -- в том смысле, что многие исследования на данную тему несут частный характер и не
имеют четко структурированной теоретической базы. Также, существуют концептуальные и онтологические сложности
в отношении этой области знаний. Например, для определения термина <<язык программирования>> в данной области
недостаточно рассматривать общепринятые варианты языков, так как чаще всего они являются GPL,
чего недостаточно в контексте межъязыкового анализа. Термин <<формальный язык>> является более подходящим, но
сильно расширяет предметную область, что затрудняет создание единой терминологической базы.

Несмотря на данные сложности, работы по межъязыковому анализу являются очень разнообразными и, рассмотрение
определенного количества таких работ позволит выявить общие аспекты анализа, которые универсальны для всех методов.
В данной работе была проведена выборка пяти различных работ по следующим показателям:
\begin{itemize}
    \item парадигма анализируемых языков,
    \item способ извлечения знаний (вовлекаемая онтологическая модель),
    \item вовлекаемые языки,
    \item сценарии использования анализаторов,
    \item возможные недостатки подхода.
\end{itemize}

\section{Pangea} \label{ssec:pangea}

Pangea \cite{pangea} это фреймворк для осуществления статического анализа, позволяющий
быстро разрабатывать различные анализаторы путем использования снимков системы (англ Object Model Snapshots).
Такие снимки являются исполняемыми образами моделей Moose \cite{moose}, которые в свою очередь получаются из
анализа исходного кода с использованием \textit{метамоделей} FAMIX \cite{famix}.

Фреймворк предназначен в первую очередь для анализа систем на основе определенных метрик,
которые в свою очередь собираются скриптом, реализованным на Smalltalk. В статье авторами показаны
различные сценарии использования фреймворка (в основном для Java приложений) -- сборка метрик и статистик,
с последующим анализом. Авторами заявляется поддержка других языков (C/C++, C\#, Smalltalk) путем использования других анализаторов,
предоставляющих результаты анализа в формате FAMIX.

Несмотря на то, что фреймворк может быть использован для многих языков, его средствами нельзя достичь именно
межъязыкового анализа, так как такой анализ подразумевает обработку межмодульных зависимостей, чего
данный фреймворк делать не позволяет. Также, одним из серьезных ограничений (в том числе замеченном авторами) является
ориентированность на OO \Abbrev{OO}{object oriented --- объектно ориентированный} языки, что ограничивает круг поддерживаемых языков.

Стоит заметить, что применение метамоделей на основе ОО парадигмы может затруднять
разработку соответствующих анализаторов. Основная причина этого -- понятия <<класс>> и <<объект>> являются довольно
размытыми семантически и их формальная реализация может разительно отличаться от языка к языку.
Основным примером такой сложности может служить сравнение языков JavaScript и Java. 

Несмотря на внешнюю схожесть, JavaScript куда больше напоминает сочетание Smalltalk и Scheme, что делает его более гибким
и, в каком-то отношении, функциональным языком. Отражение этого заключается к примеру в том, что до 
стандарта ES6 \cite{ecma262}, JavaScript считался чисто объектным языком и не содержал классов. Многие
<<классовые>> конструкции были реализованы через механизм прототипного наследования и обычные функции.
В случае Java класс является основопологающей конструкцией, основным блоком построения программ. В связи
с этим, многие семантические особенности Java (например, виртуальные вызовы или определения процедур) сильно
связаны с семантикой классов. К примеру, невозможно определить процедуру, без создания соответствующего класса.

В конце концов попытка объединения семантических понятий <<класс>> и <<объект>> сделает онтологическую модель
слишком сложной так как будет вовлекать абсолютно разные концепции из обоих языков. Решением данной проблемы
может стать использование <<меньшего>> унифицированного представления, т.е. сопровождающего
достаточное количество информации о сущности языка и при этом являющимся <<наибольшим общим делителем>>
среди различного набора языков.

\section{Статический анализ JNI связей} \label{ssec:jni}

JNI \cite{JNI} это набор API для взаимодействия виртуальной машины Java
с нативным кодом (к примеру, реализованным на C/C++ или ассемблере). Основная цель такого интерфейса --
доступ к низкоуровневым функциям, позволяющим ускорить исполнение кода на Java.

Как следует из описания, написание кода с использованием JNI влечет взаимодействие нескольких языков между
собой, в случае рассматриваемой статьи это Java и C++. В рамках статьи рассматривается статический анализ
на основе <<S-MLDA>>. Это разработанный авторами анализатор, позволяющий строить граф зависимостей вызовов 
(CDG) \Abbrev{CDG}{call-dependency graph --- граф зависимостей вызовов}
между фрагментами кода реализованными на двух языках. Процесс построения такого
графа заключается в парсинге и дальнейшем лексическом сравнении идентификаторов. В дальнейшем, такой
граф позволяет выявить связи компонентов и интерпретировать их должным образом (например, сообщить о 
несогласованности).

Основным недостатком метода является процесс лексического сравнения для реализации модели анализа.
Хотя и простой, такой метод является нестабильным и сложно поддерживаемым по следующим причинам:
\begin{itemize}
    \item имена идентификаторов неявно вовлекаются в процесс анализа семантики,
    \item возможны ложноположительные или ложноотрицательные результаты анализа при различном именовании,
    \item от версии к версии имена могут меняться, что сделает анализ менее полным.
\end{itemize}

Таким образом, метод анализа семантики посредством лексического сравнения является
довольно хрупким решением, поддерживающим малый набор языков. Также, такое решение является трудно поддерживаемым
и расширяемым в дальнейшем. 

Также стоит заметить что построение графа зависимостей вызовов является достаточно хорошим решением для многих
языков, так как широкий спектр межъязыкового взаимодействия может быть выражен через вызовы функций из одного
модуля в другом. С практической точки зрения такой подход является, пожалуй, наиболее простым в реализации, однако
такая модель сохраняет очень мало информации о семантике исходного языка, что затрудняет дальнейшее расширение
анализаторов на основе такой модели.

\section{MLSA} \label{ssec:mlsa}

MLSA (MultiLingual Software Analysis) \cite{MLSA} это метод, ориентированный на построение межъязыковых анализаторов
путем организации определенного конвеера из анализаторов двух категорий -- языкозависимых и языконезависимых.
Используя исходное AST программы на определенном языке программирования, авторами предполагается
создание транслятора из такого AST в обобщенную форму (в статье такой транслятор называется <<interop фильтр>>),
а затем анализ такой обобщенной формы в контексте нескольких языков (такой анализатор называется <<MLSA фильтр>>).
Трансляторы являются языкозависимыми, а анализаторы языконезависимыми.

Также, стоит отметить, что авторами активно используется островная грамматика \cite{island-grammars} для
распознавания только интересующих фрагментов кода. Таким образом, сочетание различных фильтров и островная грамматика
в их основе создает гибкую и модульную систему при которой возможно создание различных анализаторов различной сложности.

Однако, основной проблемой данного подхода является рост числа необходимых анализаторов при увеличении
количества взаимодействующих языков. Допустим, при анализе 10 языков, взаимодействующих между собой, необходимо
будет создать 10 языкозависимых трансляторов и 50 языконезависимых анализаторов, организованных в виде
дерева. Конечно, такой случай является утрированным, однако как уже было сказано в разделе \ref{sec:num1}, в современном
программном проекте в среднем содержится 5 языков.

Данный метод как и предыдущий полагается на использование графа зависимостей вызовов, что сужает его применимость
в контексте языков, не имеющих функций (например форматы данных).

\section{Граф вызовов, семантики и номинальной схожести} \label{ssec:graphs}

В статье \cite{SNDGA} авторами решается проблема модуляризации межъязыкового ПО путем построения специализированного графа
и анализа такого графа с использованием генетического алгоритма. В рамках данной работы интерес представляет
граф, использованный для отражения зависимостей в межъязыковом коде.

В статье используется нестандартных композитный граф, состоящий из трех различных графов:
\begin{enumerate}[1)]
    \item граф зависимостей вызовов,
    \item граф семантических зависимостей,
    \item граф номинальной схожести.
\end{enumerate}
Все три графа имеют общую основу -- узлы представляют собой <<артефакты>>. Семантика ребер при этом зависит от типа графа.
Стоит разобрать каждый граф по отдельности.

Граф зависимостей вызовов представляет собой стандартный граф, встречаемый в других работах на данную тему. Ребра данного графа
представляют собой зависимость <<вызов>>, что в общем плане является зависимостью <<использует>>. В статье граф является взвешенным, что
позволяет авторам кодировать количество <<использований>> между артефактами как вес соответствующего ребра.
Построение графа зависимостей вызовов является языкозависимой процедурой и подразумевает использование соответствующего
анализатора для каждого вовлеченного языка.

Граф семантических зависимостей строится интересным образом. Авторами используется ВЛСА \Abbrev{ВЛСА}{вероятностный латентно-семантический анализ} для получения
значения схожести двух артефактов. Артефакты объединяются между собой и вес ребер в графе при этом соответствует схожести соединенных
узлов. Таким образом, метод построения графа является чисто лексическим и вовлекает статистические методы.

Граф номинальной схожести строится по похожему принципу что и предыдущий, однако в данном графе вес ребра отвечает не
за семантическую схожесть понятий, а за лексическую. Гипотеза авторов состоит в том, что осмысленно разработанные
системы часто имеют схожие назавания связанных между собой компонентов.

В итоге три таких графа объединяются и анализируются в дальнейшем генетическим алгоритмом. Данный граф
является интересной моделью представления информации так как позволяет сильно увеличить полноту анализа, пренебрегая
корректностью. Учитывая, что корректность анализа не требуется во всех сценариях использования статических анализаторов
(допустим как в случае работы авторов), такой подход выглядит действительно адекватным для определенного круга задач.
Также, как граф семантических зависимостей так и граф номинальной схожести не требуют языкозависимого анализатора для построения, что
сильно упрощает реализацию такого анализа на практике.

\section{Polycall} \label{ssec:polycall}

Статья \cite{polycall} интересна в первую очередь выбором онтологической модели. Вместо создания 
какой-либо модели на основе формальной спецификации, авторами предполагается использование
существующего формального языка с собственной семантикой. В случае данной статьи это язык WASM \cite{wasm}.
WASM является низкоуровневым языком программирования, ориентированным на встраивание в различные решения, в первую очередь 
браузеры.

В рамках данной статьи WASM рассматривается как <<наибольший общий делитель>>, который позволяет объединить
семантику различных языков путем простой компиляции из избранного языка в WASM модуль. Такой подход позволяет
сильно упростить процесс анализа, так как языкозависимым анализатором в данном случае выступает компилятор и
основная работа может заключаться в анализе непосредственного самих WASM модулей.

Несмотря на многообещающие особенности такого подхода, он имеет ряд недостатков. 

Во-первых, при компиляции в такое унифицированное представление теряется ряд типовой информации, так как обычно она не требуется для исполнения.
Это влечет за собой вероятную потерю основной информации, способной обеспечивать полноту анализа. 

Во-вторых, способ компоновки текстов исходного языка может отличаться от способа компоновки текстов языка унифицированного представления.
Одним из ярких примеров является процесс трансформации имен (англ. Name mangling) при компиляции кода C++. Это деталь реализации
компилятора, которая позволяет осуществлять перегрузку функций по типам принимаемых параметров. Впоследствии, при связывании
фрагментов C++, компилятор использует именно такие имена. Этот механизм мешает возможности связывания с скомпилированным кодом
другого языка, например в случае модулей реализованных на С. В связи с этим в C++ существует директива \texttt{extern "C"}.

В-третьих, многие языки в ходе компиляции подвергаются процессу ловеринга. Ловеринг это процесс переписывания изначальной программы
в терминах более примитивных языковых конструкций с сохранением семантики. К примеру, в контексте JavaScript определение
класса является чистым синтаксическим сахаром и может быть переписано с использованием более базовых концепций -- функций и прототипов.
Процесс ловеринга может сделать процесс дальнейшего анализа сильно сложнее, а в некоторых случаях информация и вовсе стирается, что
делает невозможным корректный семантический анализ. Например, виртуальные методы C++ часто понижаются в отдельное определение
структуры называемое \textit{виртуальная таблица}. Таким образом, исчезает возможность получить возможные виртуальные методы
класса, так как соответствующая ему виртуальная таблица больше никак семантически не связана с классом.

\section{Результаты анализа состояния работ} \label{ssec:2:results}

Подводя итоги анализа, можно сформировать классификацию данных работ по критериям, описанным в \ref{ssec:num2}.
Данная классификация приведена в таблице \ref{current-state}.


\begin{table}[h]
    \caption{Состояние существующих анализаторов}
    \resizebox{1 \textwidth}{!}{\begin{tabular}{|p{2.8cm}|p{2.5cm}|p{3cm}|p{3cm}|p{3cm}|p{3.3cm}|}
    \hline Анализатор\slash Метод & Парадигма & Способ извлечения знаний & Вовлекаемые языки & Сценарии использования & Недостатки подхода \\
    \hline Pangea (\ref{ssec:pangea}) & ОО & OMS и Moose модели & Java, C++, C\# & Сборка метрик и анализ систем & Сложная онтологическая модель; Ограничение ОО языками; \\ 
    \hline JNI связи (\ref{ssec:jni}) & OO\slash Procedural & Лексическое сопоставление & Java\slash C++ & Анализ FFI вызовов & Лексическое сравнение; Анализ исключительно функций; \\
    \hline MLSA (\ref{ssec:mlsa}) & OO\slash Procedural & Interop\slash Multilangual фильтры & C++\slash Python & Анализ FFI вызовов; Получение зависимостей & Большое количество межъязыковых анализаторов \\
    \hline Композитные графы (\ref{ssec:graphs}) & Любая & Анализ вызовов, семантики и имен & Любые, C++\slash JavaScript & IDE, инструменты визуализации & Отсутствие корректности; Частые ложноположительные результаты \\
    \hline Polycall (\ref{ssec:polycall}) & Любая, поддерживающая WASM & Компиляция в унифицированное представление & C++, Golang, Rust & Получение зависимостей & Невыразимость представления с анализируемой семантикой \\
    \hline
    \end{tabular}}\label{current-state}
\end{table}

\clearpage