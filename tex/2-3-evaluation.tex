\chapter{Оценка показателей анализатора на избранных тестовых проектах}

Для оценки анализатора (а также в первую очередь метода анализа) было создано три тестовых проекта.
Проекты были созданы исходя из следующих критериев:
\begin{itemize}
    \item использование нескольких популярных языков в одном проекте,
    \item каждый проект решает задачу в определенной уникальной предметной области,
    \item используемые языки должны представлять различные парадигмы программирования,
    \item каждый из проектов должен вовлекать различные сценарии использования LSP.
\end{itemize}

Все полученные ограничения находятся в открытом репозитории проекта в виде файлов кода на языке TypeScript. \footnote{https://github.com/UberDever/crosslingual-analysis/tree/master/projects/crossy/lsp-adapter/examples}

\section{Пример 1 -- C\# и Visual Basic}

\subsection{Общее описание}

Приложение, реализованное на C\# использует слой взаимодействия на уровне байткода IL и имеет в зависимостях библиотеку,
реализованную на Visual Basic. Весь проект объединен через Solution файл. Такой сценарий часто встречается
в legacy приложениях, при переходе кодовой базы с Visual Basic на C\#.

Вовлекаемые языки: C\#, Visual Basic, XML (\texttt{.sln}, \texttt{.vbproj} и \texttt{.csproj} файлы).
Предположительные предметные области: Энтерпрайз приложения, частные коммерческие решения.
Рассмотренные парадигмы языков: ООП, структурированные данные.

\subsection{Окружение}

При извлечении кода могут быть использованы файлы проектов \texttt{.vbproj} и \texttt{.csproj}, в дальнейшей
достаточно построение <<слепка>> файловой структуры проекта.

\subsection{Трансляция и решение}

Трансляция может вовлекать в себя стандартный reaching definition анализ \cite{static-program-analysis} и прямое отображение
статической структуры классов и объектов на ограничения графов областей. При отображении не были использованы
структурные предикаты, так как структура модулей и классов C\# не имеет определенной семантики в отношении
типов и возможной вложенности. 

\subsection{Онтология}

Типы, добавленные в онтологию:
\begin{itemize}
    \item \texttt{Integer} -- целочисленное число неспецифицированной точности,
    \item \texttt{Top} -- супертип всех возможных типов, также является маркером отсутствия информации об идентификаторе.
\end{itemize}

\subsection{Сценарии LSP}

Для данного примера было решено реализовать два сценария использования, характерных для ООП языков: <<Type hierarchy>> 
(получение иерархии типов) и <<Go to definition/declaration>> (перейти к объявлению/использованию).
Предполагаемые примеры внешнего вида реализации таких сценариев показаны на рисунке \ref{fig:typehierarchy} и рисунке \ref{fig:gotodef}
соответственно.


\section{Пример 2 -- С++, Python 3 и Shell}

\section{Пример 3 -- Golang и JavaScript}

% TODO: 3 примера, 6 сценариев.
% Проект (описание, области, языки, парадигмы) -> необходимое/использованное окружение -> особенности трансляции -> ограничения -> подстановка -> скрины
\clearpage