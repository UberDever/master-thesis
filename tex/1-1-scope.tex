\chapter{Исследование существующих технологий и языков программирования в контексте
областей разработки программного обеспечения} \label{sec:num1}

\section{Современная индустрия разработки программного обеспечения}

Современные программные проекты, в отличие от многих программных проектов прошлого,
гораздо чаще состоят из набора разных (порой разительно) технологических
решений, предназначенных для решения определенного круга задач. Согласно \cite{empirical-analysis},
в одном программном проекте в среднем задействовано 5 языков программирования, один из
которых является <<основным>>, а остальные -- специализированными языками предметной области (DSL\Abbrev{DSL}{domain specific language ""--- язык разработанный для определенной предметной области}).
В заключении статьи авторы признают популярность мультиязыковых программных проектов
и оценивают важность наличия соответствующих инструментальных средств для работы с
такого рода проектами.

Также, нередко использование нескольких языков и в индустрии разработки. Так, авторы \cite{professional-developers}
провели исследование популярности мультиязыковых проектов
в результате опроса 139 профессиональных разработчиков из разных сфер. 
Результаты опроса показали, что опрашиваемые имели дело с 7 различными языками, в среднем.
При этом, в работу было вовлечено в среднем 3 пары связанных языков в контексте одного проекта.
Более 90\% опрашиваемых также сообщали о проблемах согласованности между языками,
встречаемых при разработке в такой мультиязыковой среде. 

Таким образом, в современной разработке программного обеспечения нередко использование
нескольких языков вне зависимости от объемов проекта или вовлекаемой предметной области.
Ситуация становится сложнее со временем, так как создание новых технологий разработки
часто влечет за собой формирование определенной нотации или языка для управления или конфигурации.
Например, это может касаться таких повсеместных технологий как СУБД\Abbrev{СУБД}{система управления базами данных}, систем сборки,
серверов приложений или скриптов развертывания.

Для наглядности, можно привести следующие языки, нередко фигурирующие в составе современных программных проектов:
\begin{itemize}    
    \item язык разметки HTML в составе проекта, использующего ASP фреймворк,
    \item язык скриптов командной строки в составе проекта, использующего язык C,
    \item язык запросов SQL в составе проекта, использующего Python и фреймворк Flask,
    \item язык препроцессора в составе файла исходного кода, реализованного на C++.
\end{itemize}

Заключительный пункт списка примеров приведен для того, чтобы показать характер
связи различных технологий -- разным языкам необязательно даже находится в раздельных
файлах или модулях, нередки случаи полноценного переплетения различных синтаксисов и
семантик.

\subsection{Актуальность мультиязыкового статического анализа}

Итак, мультиязыковые программные проекты нередки. Следовательно, имеет смысл использования
различных техник работы с исходным кодом таких проектов, поддерживающих процесс разработки.
Одной из таких техник является статический анализ исходного кода. Его основной сценарий
использования это упрощение различных сценариев процесса разработки ПО -- кодирования,
верификации, рефакторинга и других.

Стоит уточнить что имеется под определением <<статический анализ кода>>. Статический
анализ это прежде всего набор различных техник по извлечению информации о программе без её
явного запуска \cite{static-program-analysis}. Таким образом, статический анализ может
быть полезен в сценариях, которые не предполагают явного запуска программы -- в сущности во
всех сценариях процесса разработки ПО исключая этапы тестирования и запуска.

Возможные сценарии использования статического анализа кода включают (но не ограничиваются):
\begin{itemize}
    \item оптимизацию программ во время компиляции,
    \item выявление потенциальных уязвимостей,
    \item доказательство сохранения определенных инвариантов,
    \item сбор определенной статистики,
    \item выявление <<пахнущих>> фрагментов кода,
    \item извлечение информации для помощи разработчику во время кодирования (линтинг),
    \item автоматический рефакторинг кода.
\end{itemize}

Так как сценарии использования статического анализа настолько разнообразны, в рамках данной работы
решено было сосредоточится на сценариях разработки, которые помогают в процессе кодирования и поддержки проекта.
Существуют различные инструментальные средства, способные упрощать такие сценарии.
К таким средствам, к примеру, относятся:
\begin{itemize}
    \item интегрированные средства разработки (IDE\Abbrev{IDE}{integrated development environment --- интегрированная среда разработки}),
    \item линтеры (собирательное название инструментов, первым из которых был <<Lint>> \cite{Johnson1978LintAC}),
    \item инструменты автоматического рефакторинга,
    \item инструменты сбора статистики,
    \item различные кодогенераторы и фреймворки \cite{qt-moc}\cite{react}.
\end{itemize}

Необходимость в таких средствах присутствует и она достаточно высока. Так, согласно
исследованию \cite{aid-developers}, использование средств поддержки разработчика
(в данной работе это механизмы анализа и навигации по межъязыковым связям) позволяет
улучшить как скорость разработки ПО, так и уменьшить количество совершаемых ошибок. Стоит заметить,
что несмотря на количество времени, прошедшее с момента проведения исследования, 
принципы разработки ПО в данной предметной области (веб-разработка) не изменились и большинство
программных проектов веб-приложений состоят как минимум из двух языков. 
Обычно это разделение проводится по принципу фронтенд и бекенд.

Согласно обзорной статье об исследовании межъязыковых связей \cite{pragmatic-evidence}, современные средства межъязыкового
и мультиязыкового анализа остаются всё еще плохо развитыми. Особенно это касается отношения корректности
таких средств. Более того, большая их часть часто является частным решением, ориентированным на определенную
предметную область или технологию, что снижает универсальность таких средств и усложняет их интеграцию.

Так как статья содержит большую выборку литературы по обнаружению и анализу межъязыковых связей, авторам удается
установить широкую область применения межъязыкового анализа. В эту область входят такие дисциплины разработки ПО как:
\begin{itemize}
    \item семантическое понимание программ,
    \item представление знаний при сопровождении систем,
    \item рефакторинг,
    \item моделирование ПО,
    \item валидация и верификация систем,
    \item визуализация систем,
    \item сбор статистик и метрик.
\end{itemize}

Как видно из списка, большинство этих дисциплин значительно пересекаются со сценариями использования
статического анализа кода, что говорит о том что реализация такого анализа может быть очень актуальной
для обеспечения упрощения и удешевления большого количества этапов разработки ПО.

\section{Особенности мультиязыкового анализа} \label{ssec:num1}

Мультиязыковой анализ вовлекает множество особенностей существующих инструментов, так как косвенно или
непосредственно семантическая информация об этих инструментах должна быть вовлечена в процесс анализа.
Поэтому стоит рассмотреть особенности мультиязыкового анализа которые затрудняют разработку соответствующих
анализаторов и процесс анализа в целом.

\subsection{Сложности распознавания текста} \label{ssec:parsing-problem}

Так как вовлекаемые фрагменты кода написаны на разных языках, проблема анализа таких фрагментов
возникает уже на самом первом этапе -- этапе распознавания текста. Обычно процесс анализа
текста с определенной грамматикой не вызывает труда так как грамматика фиксирована и анализатор строится
стандартными средствами -- парсер генераторы, рекурсивный спуск и иные. 

Однако, в случае парсинга текста на нескольких языках возникают сложности, так как создание универсальной
грамматики (для всех анализируемых языков) обычно трудоемко и порой в целом невозможно. Таким образом остается
несколько способов распознавания текста:
\begin{enumerate}[1)]
    \item распознавание и анализ текстов по отдельности,
    \item использование смешанных парсеров (например с использованием островных грамматик \cite{island-grammars}),
    \item использование единого представления для унификации различных парсеров.
\end{enumerate}

Первый пункт является простым в реализации и работает в большинстве случаев, однако
возникают сложности при анализе единого фрагмента (например, файла), который вовлекает несколько
языков в анализ (к примеру CSS стили в заголовке страницы HTML). Также, такой подход не позволяет
проводить совместный анализ и выявлять связи между модулями, реализованными на разных языках.

Второй пункт позволяет анализировать в том числе смешанные грамматики, 
но сборка таких парсеров довольно трудоемка и ограничена поддержкой лишь определенного количества языков.

Таким образом, наиболее оптимальным является вариант распознавания при котором мультиязыковые фрагменты
изначально переводятся в единое представление (используя любой специфичный способ перевода, сохраняющий семантику), а
уже затем анализируются. В некоторых случаях такой подход является наиболее удобным так как
интересующая область анализа может вовлекать только специфическую часть информации, представленную в коде.
В таком случае, универсальное представление может быть создано с учетом только такой информации и
в результате получиться гораздо проще исходного языка. Это позволяет упростить анализатор и облегчить его
дальнейшую поддержку.

\subsection{Анализ и кодогенерация}

Несмотря на то, что кодогенерация является сложностью которую приходится учитывать и при обычном
статическом анализе, в мультиязыковых проектах эта сложность выходит на новый уровень.
Это происходит в первую очередь потому, что большое количество технологических решений, вовлекающих
разные языки используют разные подходы к кодогенерации и по разному её осуществляют.

Для понимания возможных проблем, рассмотрим следующий фрагмент кода на C++:

\begin{minted}[linenos=true]{cpp}
// function.h
#include <stdio.h>
template <typename T>
T f(T a) {
#ifdef SOMEBAR
    return a * 2;
#else
    return a + 2;
#endif
}

// main.cpp
#include "function.h"
int main()
{
#ifdef SOMEFOO
    printf("%f", f<float>(10));
#else
    printf("%d", f<int>(5));
#endif
    return 0;
}
\end{minted}

Представим что есть два файла, <<function.h>> и <<main.cpp>>. Фрагменты, соответствующие файлам, помечены
комментариями. При статическом анализе такого кода для определения того, какая версия функции в итоге будет
сгенерирована при компиляции необходимо сделать следующее:
\begin{enumerate}[1)]
    \item узнать какие значения принимают переменные среды при компиляции этих файлов,
    \item для каждого из таких значений сгенерировать возможную конфигурацию кода,
    \item проанализировать каждую конфигурацию и объединить результаты анализа.
\end{enumerate}

В отношении данного примера, возможных конфигураций будет четыре. В общем случае количество конфигураций
можно определить как мощность декартового произведения множеств значений вовлеченных переменных.
Нетрудно представить, что такое количество может быть достаточно большим, например при количестве переменных
равном 10 с учетом того что эти переменные принимают только 2 значения, количество конфигураций равно 1024.

Еще одной особенностью кодогенерации является частое вовлечение сторонних инструментов. В отличие от
примера приведенного выше, многие фреймворки различных технологических стеков полагаются на кодогенерацию во время
сборки проекта. Обычно эта кодогенерация вовлекает генерацию на уровне файлов. В данном случае статический анализ
не сможет обеспечить анализ сгенерированных файлов без использования одного из двух подходов:
\begin{itemize}
    \item запуск сборки и генерации во временной директории с последующей очисткой,
    \item абстрактная интерпретация команд генератора.
\end{itemize}

Первый подход может вызвать большие сложности если генерация имеет в зависимостях какое-либо
недоступное на момент анализа окружение. Примером может быть генерация <<файлов-определений>> для проекта,
который должен быть использован на конкретном встроенном устройстве. Такие файлы обычно являются
способом объединения конфигурации программного кода и информации для устройства. К примеру, таким файлом
является \texttt{c++config.h} который часто идет в поставке с избранным компилятором C++ и является
встроенным заголовочным файлом. Нетрудно представить, что такой файл может различаться от компилятора к
компилятору и даже от версии к версии, а также просто может не существовать, так как стандарт C++
не затрагивает встроенные определения. 
До момента размещения проекта в специализированном окружении, нет информации 
о том какого рода определения необходимо генерировать для анализа.
Такое часто происходит при разработке встроенных систем по разным причинам: количество конфигураций
устройств, упрощение процесса разработки, недоступность устройств и т.д.

Второй подход является более сложным в реализации, так как различные кодогенераторы и фреймворки редко
имеют исчерпывающую документацию по особенностям кодогенерации, поэтому кодирование такой информации
часто будет неполным. Более того, особенности кодогенерации могут быть особенностью реализации
определенного инструмента, что может поменяться со временем. Поэтому, практическая реализация
таких анализаторов это сложный процесс, требующий большого количества времени и поддержки.

\subsection{Формирование выборки для анализа}

На первый взгляд формирование выборки кажется тривиальной проблемой. При моноязыковом анализе она
решается использованием сторонних инструментов, позволяющих получить набор файлов для анализа.
Такую информацию могут предоставлять системы сборки или развертывания, в крайнем случае достаточно
поиска в файловой системе определенного множества файлов.

Однако, при вовлечении нескольких языков в проект, получение соответствующих файлов путем простого
поиска может быть неадекватным решением по следующим причинам:
\begin{itemize}
    \item компоновка проекта из отдельных, несвязанных проектов,
    \item сборка проекта зависящая от условий в текущем окружении,
    \item специфика компоновки файлов в единый модуль зависит от конкретного языка и может отличаться.
\end{itemize}

Соответственно, для успешной практической интеграции анализатора, способного проводить мультиязыковой анализ
необходимо обеспечить также поддержку внешних инструментов, позволяющих правильно выбирать файлы для
анализа основываясь на конфигурации операционного окружения проекта. Таким образом, анализ проекта
первым этапом обязан обеспечивать анализ \textit{операционного окружения} проекта. Такая особенность
сильно усложняет анализатор и накладывает ограничения на технологии с которыми он может работать, так
как операционное окружение в общем случае включает состояние всего компьютера: файловая система, переменные
среды или реестр, подключение к сети и т.д. 

В данной работе проблема выборки файлов для анализа
не рассматривается, так как она несущественна для формирования метода межъязыкового анализа, 
который независим от какого-либо анализатора, его использующего.

\subsection{Динамическая и неявная природа межъязыковых связей}

Многие семантически важные связи в реальных мультиязыковых проектах являются неявными. В большей части это применимо
к фреймворкам и системам сборки, так как порой семантическая информация распределена в разных местах проекта,
вовлекая при этом и системные зависимости \cite{professional-developers} \cite{external-dependencies}.

С точки зрения практической реализации, неявные связи являются усложняющим обстоятельством, но не
делающим анализ невозможным. К сожалению, то же нельзя сказать в отношении динамических связей. Под
динамическими связями понимаются связи, которые устанавливаются на определенном этапе исполнения кода.
Например, это может быть формирование строки в коде JavaScript, которая потом может быть использована чтобы
получить определенные теги HTML страницы.

Несмотря на наличие динамических связей в определенных языках, значительное множество языков общего назначения (GPL), \Abbrev{GPL}{general programming language --- язык общего назначения}
все же имеют статическую типизацию либо статическое время связывания идентификаторов, не вовлекающее процесс вычисления.
Это позволяет проводить эффективный статический анализ таких языков. Однако, в случае гетерогенных проектов наличие динамической
связи гораздо более распространено. Это связано с различными причинами, основная из которых, возможно,
связана с разнообразием связываемых между собой технологий. 

Например, очень частой динамической (но также вполне явной) связью является зависимость фрагмента от состояния ФС \Abbrev{ФС}{файловая система}. Это практически всегда встречается
в различных системах сборки -- скрипты сборки напрямую зависят от наличия некоторых файлов в системе и
при их отсутствии вынуждены прерывать исполнение сборки, порой после нескольких часов работы. Таким образом
тратятся как физические ресурсы, так и снижается продуктивность программиста, что может приводить к
ухудшению процесса разработки.

\subsection{Разнообразие парадигм программирования}

Как уже сказано в предыдущем подпункте, значительное множество GPL являются статически типизированными
либо имеют статическое время связывания идентификаторов. Однако, это касается по большей части
императивных языков программирования. Примерами могут служить Java, C\#, C++, Golang и другие.
Многие DSL однако, являются динамическими языками в том смысле, что они имеют позднее
связывание идентификаторов (обычно во время исполнения). Связано это в том числе с тем, что многие DSL
имеют другую парадигму программирования, что также влияет на особенность их реализации. Примерами могут служить 
языки сборки, языки командной оболочки или языки выборки данных (например, языки запросов к СУБД).

Многие фреймворки <<программируются>> не напрямую, а через конфигурационные файлы. Примером может служить
повсеместный язык разметки XML, который иногда эксплуатируется как язык описания каких-либо выражений на
определенном DSL. Ярким примером может служить система сборки Apache Ant, в ней узлы XML дерева
могут представлять обращения к переменным или даже целые выражения. Можно сказать, что любые конфигурационные
данные проекта могут представлять семантически важную информацию, так как использование конфигурационных
файлов в гетерогенных проектах повсеместно \cite{external-dependencies}.

Это приводит к тому, что некоторые вовлекаемые в анализ языки не являются языками программирования, но
всё же представляют семантическую ценность для анализа. Вследствие этого возникает проблема создания
метода такого анализа, который в том числе будет вовлекать такого рода фрагменты.

\subsection{Результаты исследования}

Подводя итоги раздела \ref{sec:num1}, можно сказать что современные проекты действительно
часто реализованы на различных языках, т.е. являются гетерогенными. Такой положение вещей
затрудняет многие сценарии разработки ПО и создание метода анализа обеспечивающего выявление межъязыковых
связей является хорошим способом решения многих возникающих проблем.

Также, на основе подпункта \ref{ssec:num1} можно выявить желаемые особенности метода мультиязыкового анализа:
\begin{enumerate}[1)]
    \item анализ с использованием единого представления является более эффективным решением ввиду большей универсальности,
    \item желательна поддержка сценариев кодогенерации, либо возможность их реализации,
    \item необходимо вовлечение операционного окружения проекта для обеспечения корректности анализа,
    \item эффективный анализ должен быть универсальным для многих языков и парадигм программирования.
\end{enumerate}

\clearpage